<!DOCTYPE html>
<html><head><title>C:\Users\micha\OneDrive\Dokumente\GitHub\matRad\dicom\matRad_importDicomSteeringParticles.m</title><STYLE TYPE="text/css"><!--TD{font-family: "Courier New", Courier, monospace; font-size: 10pt;}---></STYLE></head><body><p>(Back to <a href="index.html">index</a>)</p><h1>C:\Users\micha\OneDrive\Dokumente\GitHub\matRad\dicom\matRad_importDicomSteeringParticles.m</h1><p style="font-family:'Courier New'"><table>
<tr><th>Line</th><th>Code</th></tr>
<tr><td>1</td><td bgcolor="#FFFFFF">function&nbsp;[stf,&nbsp;pln]&nbsp;=&nbsp;matRad_importDicomSteeringParticles(ct,&nbsp;pln,&nbsp;rtPlanFile)</td></tr>
<tr><td>2</td><td bgcolor="#FFFFFF">%&nbsp;matRad&nbsp;function&nbsp;to&nbsp;import&nbsp;a&nbsp;matRad&nbsp;stf&nbsp;struct&nbsp;from&nbsp;dicom&nbsp;RTPLAN&nbsp;data</td></tr>
<tr><td>3</td><td bgcolor="#FFFFFF">%&nbsp;</td></tr>
<tr><td>4</td><td bgcolor="#FFFFFF">%&nbsp;call</td></tr>
<tr><td>5</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;[stf,&nbsp;pln]&nbsp;=&nbsp;matRad_importDicomSteeringParticles(ct,&nbsp;pln,&nbsp;rtPlanFile)</td></tr>
<tr><td>6</td><td bgcolor="#FFFFFF">%</td></tr>
<tr><td>7</td><td bgcolor="#FFFFFF">%&nbsp;input</td></tr>
<tr><td>8</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;ct:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct&nbsp;imported&nbsp;by&nbsp;the&nbsp;matRad_importDicomCt&nbsp;function</td></tr>
<tr><td>9</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;pln:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matRad&nbsp;pln&nbsp;struct&nbsp;with&nbsp;meta&nbsp;information</td></tr>
<tr><td>10</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;rtPlanFile:&nbsp;&nbsp;&nbsp;	name&nbsp;of&nbsp;RTPLAN&nbsp;DICOM&nbsp;file</td></tr>
<tr><td>11</td><td bgcolor="#FFFFFF">%</td></tr>
<tr><td>12</td><td bgcolor="#FFFFFF">%&nbsp;output</td></tr>
<tr><td>13</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;stf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matRad&nbsp;stf&nbsp;struct</td></tr>
<tr><td>14</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;pln:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matRad&nbsp;pln&nbsp;struct.&nbsp;</td></tr>
<tr><td>15</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note:&nbsp;pln&nbsp;is&nbsp;input&nbsp;and&nbsp;output&nbsp;since&nbsp;pln.bixelWidth&nbsp;is&nbsp;</td></tr>
<tr><td>16</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;determined&nbsp;here.</td></tr>
<tr><td>17</td><td bgcolor="#FFFFFF">%</td></tr>
<tr><td>18</td><td bgcolor="#FFFFFF">%&nbsp;References</td></tr>
<tr><td>19</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;-</td></tr>
<tr><td>20</td><td bgcolor="#FFFFFF">%&nbsp;Note</td></tr>
<tr><td>21</td><td bgcolor="#FFFFFF">%&nbsp;not&nbsp;implemented&nbsp;-&nbsp;compensator.&nbsp;Fixed&nbsp;SAD.</td></tr>
<tr><td>22</td><td bgcolor="#FFFFFF">%&nbsp;</td></tr>
<tr><td>23</td><td bgcolor="#FFFFFF">%&nbsp;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</td></tr>
<tr><td>24</td><td bgcolor="#FFFFFF">%</td></tr>
<tr><td>25</td><td bgcolor="#FFFFFF">%&nbsp;Copyright&nbsp;2015&nbsp;the&nbsp;matRad&nbsp;development&nbsp;team.&nbsp;</td></tr>
<tr><td>26</td><td bgcolor="#FFFFFF">%&nbsp;</td></tr>
<tr><td>27</td><td bgcolor="#FFFFFF">%&nbsp;This&nbsp;file&nbsp;is&nbsp;part&nbsp;of&nbsp;the&nbsp;matRad&nbsp;project.&nbsp;It&nbsp;is&nbsp;subject&nbsp;to&nbsp;the&nbsp;license&nbsp;</td></tr>
<tr><td>28</td><td bgcolor="#FFFFFF">%&nbsp;terms&nbsp;in&nbsp;the&nbsp;LICENSE&nbsp;file&nbsp;found&nbsp;in&nbsp;the&nbsp;top-level&nbsp;directory&nbsp;of&nbsp;this&nbsp;</td></tr>
<tr><td>29</td><td bgcolor="#FFFFFF">%&nbsp;distribution&nbsp;and&nbsp;at&nbsp;https://github.com/e0404/matRad/LICENSES.txt.&nbsp;No&nbsp;part&nbsp;</td></tr>
<tr><td>30</td><td bgcolor="#FFFFFF">%&nbsp;of&nbsp;the&nbsp;matRad&nbsp;project,&nbsp;including&nbsp;this&nbsp;file,&nbsp;may&nbsp;be&nbsp;copied,&nbsp;modified,&nbsp;</td></tr>
<tr><td>31</td><td bgcolor="#FFFFFF">%&nbsp;propagated,&nbsp;or&nbsp;distributed&nbsp;except&nbsp;according&nbsp;to&nbsp;the&nbsp;terms&nbsp;contained&nbsp;in&nbsp;the&nbsp;</td></tr>
<tr><td>32</td><td bgcolor="#FFFFFF">%&nbsp;LICENSE&nbsp;file.</td></tr>
<tr><td>33</td><td bgcolor="#FFFFFF">%</td></tr>
<tr><td>34</td><td bgcolor="#FFFFFF">%&nbsp;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</td></tr>
<tr><td>35</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>36</td><td bgcolor="#FFFFFF">%%&nbsp;load&nbsp;plan&nbsp;file</td></tr>
<tr><td>37</td><td bgcolor="#FFFFFF">%&nbsp;load&nbsp;machine&nbsp;data</td></tr>
<tr><td>38</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>39</td><td bgcolor="#FF0000">dlgBaseDataText&nbsp;=&nbsp;['Import&nbsp;steering&nbsp;information&nbsp;from&nbsp;DICOM&nbsp;Plan.','Choose&nbsp;corresponding&nbsp;matRad&nbsp;base&nbsp;data&nbsp;for&nbsp;',&nbsp;...</td></tr>
<tr><td>40</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pln.radiationMode,&nbsp;'.'];</td></tr>
<tr><td>41</td><td bgcolor="#FFFFFF">%&nbsp;messagebox&nbsp;only&nbsp;necessary&nbsp;for&nbsp;non&nbsp;windows&nbsp;users</td></tr>
<tr><td>42</td><td bgcolor="#FF0000">if&nbsp;~ispc</td></tr>
<tr><td>43</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;uiwait(helpdlg(dlgBaseDataText,['DICOM&nbsp;import&nbsp;-&nbsp;',&nbsp;pln.radiationMode,&nbsp;'&nbsp;base&nbsp;data'&nbsp;]));</td></tr>
<tr><td>44</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>45</td><td bgcolor="#FF0000">[fileName,pathName]&nbsp;=&nbsp;uigetfile('*.mat',&nbsp;dlgBaseDataText);</td></tr>
<tr><td>46</td><td bgcolor="#FF0000">load([pathName&nbsp;filesep&nbsp;fileName]);</td></tr>
<tr><td>47</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>48</td><td bgcolor="#FF0000">ix&nbsp;=&nbsp;find(fileName&nbsp;==&nbsp;'_');</td></tr>
<tr><td>49</td><td bgcolor="#FF0000">pln.machine&nbsp;=&nbsp;fileName(ix(1)+1:end-4);</td></tr>
<tr><td>50</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>51</td><td bgcolor="#FFFFFF">%&nbsp;RT&nbsp;Plan&nbsp;consists&nbsp;only&nbsp;on&nbsp;meta&nbsp;information</td></tr>
<tr><td>52</td><td bgcolor="#FF0000">if&nbsp;verLessThan('matlab','9')</td></tr>
<tr><td>53</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;rtPlanInfo&nbsp;=&nbsp;dicominfo(rtPlanFile{1});</td></tr>
<tr><td>54</td><td bgcolor="#FFFFFF">else</td></tr>
<tr><td>55</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;rtPlanInfo&nbsp;=&nbsp;dicominfo(rtPlanFile{1},'UseDictionaryVR',true);</td></tr>
<tr><td>56</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>57</td><td bgcolor="#FF0000">BeamSeq&nbsp;=&nbsp;rtPlanInfo.IonBeamSequence;</td></tr>
<tr><td>58</td><td bgcolor="#FF0000">BeamSeqNames&nbsp;=&nbsp;fieldnames(BeamSeq);</td></tr>
<tr><td>59</td><td bgcolor="#FFFFFF">%&nbsp;Number&nbsp;of&nbsp;Beams&nbsp;from&nbsp;plan</td></tr>
<tr><td>60</td><td bgcolor="#FF0000">numOfBeamsPlan&nbsp;=&nbsp;length(pln.propStf.gantryAngles);</td></tr>
<tr><td>61</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>62</td><td bgcolor="#FFFFFF">%&nbsp;use&nbsp;only&nbsp;the&nbsp;treatment&nbsp;beams</td></tr>
<tr><td>63</td><td bgcolor="#FF0000">for&nbsp;i&nbsp;=&nbsp;1:length(BeamSeqNames)</td></tr>
<tr><td>64</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;currBeamSeq&nbsp;=&nbsp;BeamSeq.(BeamSeqNames{i});</td></tr>
<tr><td>65</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;try</td></tr>
<tr><td>66</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;treatDelType&nbsp;=&nbsp;currBeamSeq.TreatmentDeliveryType;</td></tr>
<tr><td>67</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;~strcmpi(treatDelType,'TREATMENT')</td></tr>
<tr><td>68</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeamSeq&nbsp;=&nbsp;rmfield(BeamSeq,BeamSeqNames{i});</td></tr>
<tr><td>69</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>70</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;catch</td></tr>
<tr><td>71</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warning('Something&nbsp;went&nbsp;wrong&nbsp;while&nbsp;determining&nbsp;the&nbsp;type&nbsp;of&nbsp;the&nbsp;beam.');</td></tr>
<tr><td>72</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>73</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>74</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>75</td><td bgcolor="#FFFFFF">%&nbsp;reinitialize&nbsp;the&nbsp;BeamSeqNames&nbsp;and&nbsp;length,&nbsp;as&nbsp;the&nbsp;Seq&nbsp;itself&nbsp;is&nbsp;reduced.</td></tr>
<tr><td>76</td><td bgcolor="#FF0000">BeamSeqNames&nbsp;=&nbsp;fieldnames(BeamSeq);</td></tr>
<tr><td>77</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>78</td><td bgcolor="#FFFFFF">%&nbsp;remove&nbsp;empty&nbsp;ControlPointSequences</td></tr>
<tr><td>79</td><td bgcolor="#FF0000">for&nbsp;i&nbsp;=&nbsp;1:length(BeamSeqNames)</td></tr>
<tr><td>80</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;currBeamSeq&nbsp;=&nbsp;BeamSeq.(BeamSeqNames{i});</td></tr>
<tr><td>81</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;ControlPointSeq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;currBeamSeq.IonControlPointSequence;</td></tr>
<tr><td>82</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;ControlPointSeqNames&nbsp;=&nbsp;fieldnames(ControlPointSeq);</td></tr>
<tr><td>83</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;numOfContrPointSeq&nbsp;=&nbsp;length(ControlPointSeqNames);</td></tr>
<tr><td>84</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;currContr&nbsp;=&nbsp;1:numOfContrPointSeq</td></tr>
<tr><td>85</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currContrSeq&nbsp;=&nbsp;ControlPointSeq.(ControlPointSeqNames{currContr});</td></tr>
<tr><td>86</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;sum(currContrSeq.ScanSpotMetersetWeights)&nbsp;==&nbsp;0</td></tr>
<tr><td>87</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ControlPointSeq&nbsp;=&nbsp;rmfield(ControlPointSeq,ControlPointSeqNames{currContr});</td></tr>
<tr><td>88</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>89</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>90</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;BeamSeq.(BeamSeqNames{i}).IonControlPointSequence&nbsp;=&nbsp;ControlPointSeq;</td></tr>
<tr><td>91</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>92</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>93</td><td bgcolor="#FFFFFF">%&nbsp;check&nbsp;if&nbsp;number&nbsp;of&nbsp;beams&nbsp;correspond</td></tr>
<tr><td>94</td><td bgcolor="#FF0000">if&nbsp;~isequal(length(BeamSeqNames),numOfBeamsPlan)</td></tr>
<tr><td>95</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;warning('Number&nbsp;of&nbsp;beams&nbsp;from&nbsp;beamsequences&nbsp;do&nbsp;not&nbsp;correspond&nbsp;to&nbsp;number&nbsp;of&nbsp;Gantry&nbsp;Angles');</td></tr>
<tr><td>96</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>97</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>98</td><td bgcolor="#FFFFFF">%%&nbsp;generate&nbsp;stf&nbsp;struct</td></tr>
<tr><td>99</td><td bgcolor="#FFFFFF">%&nbsp;surfaceEntry&nbsp;=&nbsp;BeamSeq.Item_1.IonControlPointSequence.Item_1.SurfaceEntryPoint;</td></tr>
<tr><td>100</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>101</td><td bgcolor="#FFFFFF">%&nbsp;Preallocate&nbsp;stf</td></tr>
<tr><td>102</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).gantryAngle&nbsp;=&nbsp;[];</td></tr>
<tr><td>103</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).couchAngle&nbsp;=&nbsp;[];</td></tr>
<tr><td>104</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).bixelWidth&nbsp;=&nbsp;[];</td></tr>
<tr><td>105</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).radiationMode&nbsp;=&nbsp;[];</td></tr>
<tr><td>106</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).SAD&nbsp;=&nbsp;[];</td></tr>
<tr><td>107</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).isoCenter&nbsp;=&nbsp;[];</td></tr>
<tr><td>108</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).sourcePoint_bev&nbsp;=&nbsp;[];</td></tr>
<tr><td>109</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).numOfRays&nbsp;=&nbsp;[];</td></tr>
<tr><td>110</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).numOfBixelsPerRay&nbsp;=&nbsp;[];</td></tr>
<tr><td>111</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).totalNumOfBixels&nbsp;=&nbsp;[];</td></tr>
<tr><td>112</td><td bgcolor="#FF0000">stf(length(BeamSeqNames)).ray&nbsp;=&nbsp;[];</td></tr>
<tr><td>113</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>114</td><td bgcolor="#FF0000">for&nbsp;i&nbsp;=&nbsp;1:length(BeamSeqNames)</td></tr>
<tr><td>115</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;currBeamSeq&nbsp;=&nbsp;BeamSeq.(BeamSeqNames{i});</td></tr>
<tr><td>116</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;ControlPointSeq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;currBeamSeq.IonControlPointSequence;</td></tr>
<tr><td>117</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).gantryAngle&nbsp;&nbsp;&nbsp;=&nbsp;pln.propStf.gantryAngles(i);</td></tr>
<tr><td>118</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).couchAngle&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;pln.propStf.couchAngles(i);</td></tr>
<tr><td>119</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).bixelWidth&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;pln.propStf.bixelWidth;</td></tr>
<tr><td>120</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).radiationMode&nbsp;=&nbsp;pln.radiationMode;</td></tr>
<tr><td>121</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;there&nbsp;might&nbsp;be&nbsp;several&nbsp;SAD's,&nbsp;e.g.&nbsp;compensator?</td></tr>
<tr><td>122</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).SAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;machine.meta.SAD;</td></tr>
<tr><td>123</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).isoCenter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;pln.propStf.isoCenter(i,:);</td></tr>
<tr><td>124</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).sourcePoint_bev&nbsp;=&nbsp;[0&nbsp;-stf(i).SAD&nbsp;0];</td></tr>
<tr><td>125</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;now&nbsp;loop&nbsp;over&nbsp;ControlPointSequences</td></tr>
<tr><td>126</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;ControlPointSeqNames&nbsp;=&nbsp;fieldnames(ControlPointSeq);</td></tr>
<tr><td>127</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;numOfContrPointSeq&nbsp;=&nbsp;length(ControlPointSeqNames);</td></tr>
<tr><td>128</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;create&nbsp;empty&nbsp;helper&nbsp;matrix</td></tr>
<tr><td>129</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;temporarySteering&nbsp;=&nbsp;zeros(0,8);</td></tr>
<tr><td>130</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;currContr&nbsp;=&nbsp;1:numOfContrPointSeq</td></tr>
<tr><td>131</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currContrSeq&nbsp;=&nbsp;ControlPointSeq.(ControlPointSeqNames{currContr});</td></tr>
<tr><td>132</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;get&nbsp;energy,&nbsp;equal&nbsp;for&nbsp;all&nbsp;coming&nbsp;elements&nbsp;in&nbsp;the&nbsp;next&nbsp;loop</td></tr>
<tr><td>133</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currEnergy&nbsp;=&nbsp;currContrSeq.NominalBeamEnergy;</td></tr>
<tr><td>134</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;get&nbsp;focusValue</td></tr>
<tr><td>135</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currFocus&nbsp;=&nbsp;unique(currContrSeq.ScanningSpotSize);</td></tr>
<tr><td>136</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;get&nbsp;the&nbsp;Spotpositions</td></tr>
<tr><td>137</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numOfScanSpots&nbsp;=&nbsp;currContrSeq.NumberOfScanSpotPositions;</td></tr>
<tr><td>138</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;x&nbsp;is&nbsp;1,&nbsp;3,&nbsp;5&nbsp;...;&nbsp;y&nbsp;2,&nbsp;4,&nbsp;6,</td></tr>
<tr><td>139</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1_help&nbsp;=&nbsp;currContrSeq.ScanSpotPositionMap(1:2:(2&nbsp;*&nbsp;numOfScanSpots));</td></tr>
<tr><td>140</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2_help&nbsp;=&nbsp;currContrSeq.ScanSpotPositionMap(2:2:(2&nbsp;*&nbsp;numOfScanSpots));</td></tr>
<tr><td>141</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight_help&nbsp;=&nbsp;currContrSeq.ScanSpotMetersetWeights;</td></tr>
<tr><td>142</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;isfield(currContrSeq,&nbsp;'RangeShifterSettingsSequence')</td></tr>
<tr><td>143</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;rangeshifter&nbsp;identification</td></tr>
<tr><td>144</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rashiID&nbsp;=&nbsp;currContrSeq.RangeShifterSettingsSequence.Item_1.ReferencedRangeShifterNumber;</td></tr>
<tr><td>145</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;rangeshifter&nbsp;waterequivalent&nbsp;thickness</td></tr>
<tr><td>146</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rashiWeThickness&nbsp;=&nbsp;currContrSeq.RangeShifterSettingsSequence.Item_1.RangeShifterWaterEquivalentThickness;</td></tr>
<tr><td>147</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;rangeshifter&nbsp;isocenter&nbsp;to&nbsp;range&nbsp;shifter&nbsp;distance</td></tr>
<tr><td>148</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rashiIsoRangeDist&nbsp;=&nbsp;currContrSeq.RangeShifterSettingsSequence.Item_1.IsocenterToRangeShifterDistance;</td></tr>
<tr><td>149</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elseif&nbsp;currContr&nbsp;==&nbsp;1</td></tr>
<tr><td>150</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rashiID&nbsp;=&nbsp;0;</td></tr>
<tr><td>151</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rashiWeThickness&nbsp;=&nbsp;0;</td></tr>
<tr><td>152</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rashiIsoRangeDist&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>153</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</td></tr>
<tr><td>154</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;in&nbsp;this&nbsp;case&nbsp;range&nbsp;shifter&nbsp;settings&nbsp;has&nbsp;not&nbsp;changed&nbsp;between&nbsp;this</td></tr>
<tr><td>155</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;and&nbsp;previous&nbsp;control&nbsp;sequence,&nbsp;so&nbsp;reuse&nbsp;values.</td></tr>
<tr><td>156</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>157</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temporarySteering&nbsp;=&nbsp;[temporarySteering;&nbsp;c1_help&nbsp;c2_help&nbsp;...</td></tr>
<tr><td>158</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(currEnergy&nbsp;*&nbsp;ones(numOfScanSpots,1))&nbsp;weight_help&nbsp;(currFocus&nbsp;*&nbsp;ones(numOfScanSpots,1))&nbsp;...</td></tr>
<tr><td>159</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rashiID&nbsp;*&nbsp;ones(numOfScanSpots,1))&nbsp;(rashiWeThickness&nbsp;*&nbsp;ones(numOfScanSpots,1))&nbsp;(rashiIsoRangeDist&nbsp;*&nbsp;ones(numOfScanSpots,1))];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>160</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>161</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>162</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;finds&nbsp;all&nbsp;unique&nbsp;rays&nbsp;and&nbsp;saves&nbsp;them&nbsp;in&nbsp;to&nbsp;the&nbsp;stf</td></tr>
<tr><td>163</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;[RayPosTmp,&nbsp;~,&nbsp;ic]&nbsp;=&nbsp;unique(temporarySteering(:,1:2),&nbsp;'rows');</td></tr>
<tr><td>164</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;clear&nbsp;ray;</td></tr>
<tr><td>165</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:size(RayPosTmp,1)</td></tr>
<tr><td>166</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).rayPos_bev&nbsp;=&nbsp;double([RayPosTmp(j,1)&nbsp;0&nbsp;RayPosTmp(j,2)]);</td></tr>
<tr><td>167</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).energy&nbsp;=&nbsp;[];</td></tr>
<tr><td>168</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).focusFWHM&nbsp;=&nbsp;[];</td></tr>
<tr><td>169</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).focusIx&nbsp;=&nbsp;[];</td></tr>
<tr><td>170</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).weight&nbsp;=&nbsp;[];</td></tr>
<tr><td>171</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).rangeShifter&nbsp;=&nbsp;struct();</td></tr>
<tr><td>172</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ray(j).ID&nbsp;=&nbsp;[];</td></tr>
<tr><td>173</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ray(j).eqThickness&nbsp;=&nbsp;[];</td></tr>
<tr><td>174</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ray(j).sourceRashiDistance&nbsp;=&nbsp;[];</td></tr>
<tr><td>175</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>176</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>177</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;saves&nbsp;all&nbsp;energies&nbsp;and&nbsp;weights&nbsp;to&nbsp;their&nbsp;corresponding&nbsp;ray</td></tr>
<tr><td>178</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:size(temporarySteering,1)</td></tr>
<tr><td>179</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;ic(j);</td></tr>
<tr><td>180</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(k).energy&nbsp;=&nbsp;[stf(i).ray(k).energy&nbsp;double(temporarySteering(j,3))];</td></tr>
<tr><td>181</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(k).focusFWHM&nbsp;=&nbsp;[stf(i).ray(k).focusFWHM&nbsp;double(temporarySteering(j,5))];</td></tr>
<tr><td>182</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(k).weight&nbsp;=&nbsp;[stf(i).ray(k).weight&nbsp;double(temporarySteering(j,4))&nbsp;/&nbsp;1e6];</td></tr>
<tr><td>183</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;helpers&nbsp;to&nbsp;construct&nbsp;something&nbsp;like&nbsp;a(:).b&nbsp;=&nbsp;c.b(:)&nbsp;after&nbsp;this</td></tr>
<tr><td>184</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;loop</td></tr>
<tr><td>185</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ray(k).ID&nbsp;=&nbsp;[ray(k).ID&nbsp;double(temporarySteering(j,6))];</td></tr>
<tr><td>186</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ray(k).eqThickness&nbsp;=&nbsp;[ray(k).eqThickness&nbsp;double(temporarySteering(j,7))];</td></tr>
<tr><td>187</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ray(k).sourceRashiDistance&nbsp;=&nbsp;[ray(k).sourceRashiDistance&nbsp;double(temporarySteering(j,8))];</td></tr>
<tr><td>188</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>189</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>190</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;reassign&nbsp;to&nbsp;preserve&nbsp;data&nbsp;structure</td></tr>
<tr><td>191</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:numel(ray)</td></tr>
<tr><td>192</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;1:numel(ray(j).ID)</td></tr>
<tr><td>193</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).rangeShifter(k).ID&nbsp;=&nbsp;ray(j).ID(k);</td></tr>
<tr><td>194</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).rangeShifter(k).eqThickness&nbsp;=&nbsp;ray(j).eqThickness(k);</td></tr>
<tr><td>195</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).rangeShifter(k).sourceRashiDistance&nbsp;=&nbsp;stf(i).SAD&nbsp;-&nbsp;ray(j).sourceRashiDistance(k);</td></tr>
<tr><td>196</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>197</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>198</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>199</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>200</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;getting&nbsp;some&nbsp;information&nbsp;of&nbsp;the&nbsp;rays</td></tr>
<tr><td>201</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;clean&nbsp;up&nbsp;energies,&nbsp;so&nbsp;they&nbsp;appear&nbsp;only&nbsp;one&nbsp;time&nbsp;per&nbsp;energy</td></tr>
<tr><td>202</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;numOfRays&nbsp;=&nbsp;size(stf(i).ray,2);</td></tr>
<tr><td>203</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;l&nbsp;=&nbsp;1:numOfRays</td></tr>
<tr><td>204</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(l).energy&nbsp;=&nbsp;unique(stf(i).ray(l).energy);</td></tr>
<tr><td>205</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(l).targetPoint_bev&nbsp;=&nbsp;[2*stf(i).ray(l).rayPos_bev(1)&nbsp;...</td></tr>
<tr><td>206</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine.meta.SAD&nbsp;...</td></tr>
<tr><td>207</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2*stf(i).ray(l).rayPos_bev(3)];</td></tr>
<tr><td>208</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>209</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).numOfRays&nbsp;=&nbsp;numel(stf(i).ray);&nbsp;&nbsp;</td></tr>
<tr><td>210</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>211</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;save&nbsp;total&nbsp;number&nbsp;of&nbsp;bixels</td></tr>
<tr><td>212</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;numOfBixels&nbsp;=&nbsp;0;</td></tr>
<tr><td>213</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:numel(stf(i).ray)</td></tr>
<tr><td>214</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numOfBixels&nbsp;=&nbsp;numOfBixels&nbsp;+&nbsp;numel(stf(i).ray(j).energy);</td></tr>
<tr><td>215</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).numOfBixelsPerRay(j)&nbsp;=&nbsp;numel(stf(i).ray(j).energy);</td></tr>
<tr><td>216</td><td bgcolor="#FFFFFF">%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;[w&nbsp;stf(currBeam).ray(j).weight];</td></tr>
<tr><td>217</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>218</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>219</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).totalNumOfBixels&nbsp;=&nbsp;numOfBixels;</td></tr>
<tr><td>220</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>221</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;get&nbsp;bixelwidth</td></tr>
<tr><td>222</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;bixelWidth_help&nbsp;=&nbsp;zeros(size(stf(i).ray,2),2);</td></tr>
<tr><td>223</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:stf(i).numOfRays</td></tr>
<tr><td>224</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bixelWidth_help(j,1)&nbsp;=&nbsp;stf(i).ray(j).rayPos_bev(1);</td></tr>
<tr><td>225</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bixelWidth_help(j,2)&nbsp;=&nbsp;stf(i).ray(j).rayPos_bev(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>226</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>227</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;bixelWidth_help1&nbsp;=&nbsp;unique(round(1e3*bixelWidth_help(:,1))/1e3,'sorted');</td></tr>
<tr><td>228</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;bixelWidth_help2&nbsp;=&nbsp;unique(round(1e3*bixelWidth_help(:,2))/1e3,'sorted');</td></tr>
<tr><td>229</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>230</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;bixelWidth&nbsp;=&nbsp;unique([unique(diff(bixelWidth_help1))'&nbsp;unique(diff(bixelWidth_help2))']);</td></tr>
<tr><td>231</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>232</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;numel(bixelWidth)&nbsp;==&nbsp;1</td></tr>
<tr><td>233</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).bixelWidth&nbsp;=&nbsp;bixelWidth;</td></tr>
<tr><td>234</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;else</td></tr>
<tr><td>235</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).bixelWidth&nbsp;=&nbsp;NaN;</td></tr>
<tr><td>236</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>237</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>238</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;coordinate&nbsp;transformation&nbsp;with&nbsp;rotation&nbsp;matrix.</td></tr>
<tr><td>239</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;use&nbsp;transpose&nbsp;matrix&nbsp;because&nbsp;we&nbsp;are&nbsp;working&nbsp;with&nbsp;row&nbsp;vectors</td></tr>
<tr><td>240</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;rotMat_vectors_T&nbsp;=&nbsp;transpose(matRad_getRotationMatrix(pln.propStf.gantryAngles(i),pln.propStf.couchAngles(i)));</td></tr>
<tr><td>241</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>242</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;Rotated&nbsp;Source&nbsp;point&nbsp;(1st&nbsp;gantry,&nbsp;2nd&nbsp;couch)</td></tr>
<tr><td>243</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).sourcePoint&nbsp;=&nbsp;stf(i).sourcePoint_bev*rotMat_vectors_T;</td></tr>
<tr><td>244</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>245</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;Save&nbsp;ray&nbsp;and&nbsp;target&nbsp;position&nbsp;in&nbsp;lps&nbsp;system.</td></tr>
<tr><td>246</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:stf(i).numOfRays</td></tr>
<tr><td>247</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).rayPos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;stf(i).ray(j).rayPos_bev*rotMat_vectors_T;</td></tr>
<tr><td>248</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).targetPoint&nbsp;=&nbsp;stf(i).ray(j).targetPoint_bev*rotMat_vectors_T;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>249</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>250</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>251</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;book&nbsp;keeping&nbsp;&amp;&nbsp;calculate&nbsp;focus&nbsp;index</td></tr>
<tr><td>252</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:stf(i).numOfRays</td></tr>
<tr><td>253</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).numOfBixelsPerRay(j)&nbsp;=&nbsp;numel([stf(i).ray(j).energy]);</td></tr>
<tr><td>254</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>255</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>256</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;use&nbsp;the&nbsp;original&nbsp;machine&nbsp;energies</td></tr>
<tr><td>257</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:stf(i).numOfRays</td></tr>
<tr><td>258</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;loop&nbsp;over&nbsp;all&nbsp;energies</td></tr>
<tr><td>259</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numOfEnergy&nbsp;=&nbsp;length(stf(i).ray(j).energy);</td></tr>
<tr><td>260</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;1:numOfEnergy</td></tr>
<tr><td>261</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;energyIndex&nbsp;=&nbsp;find(abs([machine.data(:).energy]-stf(i).ray(j).energy(k))&lt;10^-2);</td></tr>
<tr><td>262</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;~isempty(energyIndex)</td></tr>
<tr><td>263</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).energy(k)&nbsp;=&nbsp;machine.data(energyIndex).energy;</td></tr>
<tr><td>264</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</td></tr>
<tr><td>265</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error('No&nbsp;match&nbsp;between&nbsp;imported&nbsp;and&nbsp;machine&nbsp;data.&nbsp;Maybe&nbsp;wrong&nbsp;machine&nbsp;loaded.');</td></tr>
<tr><td>266</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>267</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>268</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>269</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>270</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;get&nbsp;focusIx&nbsp;instead&nbsp;of&nbsp;focusFWHM</td></tr>
<tr><td>271</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;=&nbsp;1:stf(i).numOfRays</td></tr>
<tr><td>272</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;loop&nbsp;over&nbsp;all&nbsp;energies</td></tr>
<tr><td>273</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numOfEnergy&nbsp;=&nbsp;length(stf(i).ray(j).energy);</td></tr>
<tr><td>274</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;1:numOfEnergy</td></tr>
<tr><td>275</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;energyTemp&nbsp;=&nbsp;stf(i).ray(j).energy(k);</td></tr>
<tr><td>276</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;focusFWHM&nbsp;=&nbsp;stf(i).ray(j).focusFWHM(k);</td></tr>
<tr><td>277</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;energyIxTemp&nbsp;=&nbsp;find([machine.data.energy]&nbsp;==&nbsp;energyTemp);</td></tr>
<tr><td>278</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;focusIxTemp&nbsp;=&nbsp;find(abs([machine.data(energyIxTemp).initFocus.SisFWHMAtIso]&nbsp;-&nbsp;focusFWHM&nbsp;)&lt;&nbsp;10^-3);</td></tr>
<tr><td>279</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).focusIx(k)&nbsp;=&nbsp;focusIxTemp;</td></tr>
<tr><td>280</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stf(i).ray(j).focusFWHM(k)&nbsp;=&nbsp;machine.data(energyIxTemp).initFocus.SisFWHMAtIso(stf(i).ray(j).focusIx(k));</td></tr>
<tr><td>281</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>282</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;end</td></tr>
<tr><td>283</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>284</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;stf(i).timeStamp&nbsp;=&nbsp;datestr(clock);</td></tr>
<tr><td>285</td><td bgcolor="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>286</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>287</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>288</td><td bgcolor="#FF0000">if&nbsp;any(isnan([stf(:).bixelWidth]))&nbsp;||&nbsp;numel(unique([stf(:).bixelWidth]))&nbsp;&gt;&nbsp;1</td></tr>
<tr><td>289</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;pln.propStf.bixelWidth&nbsp;=&nbsp;NaN;</td></tr>
<tr><td>290</td><td bgcolor="#FFFFFF">else</td></tr>
<tr><td>291</td><td bgcolor="#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;pln.propStf.bixelWidth&nbsp;=&nbsp;stf(1).bixelWidth;</td></tr>
<tr><td>292</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>293</td><td bgcolor="#FFFFFF"></td></tr>
<tr><td>294</td><td bgcolor="#FFFFFF">end</td></tr>
<tr><td>295</td><td bgcolor="#FFFFFF"></td></tr>
</table></p></body></html>